# AsyncCalculationWebService

# Распределенный вычислитель арифметических выражений с аутентификацией пользователей

## Введение
**Распределенный вычислитель арифметических выражений** — это система, разработанная для высокопроизводительных вычислений арифметических выражений в распределенной и параллельной среде. Проект ориентирован на безопасность и масштабируемость, обеспечивая доступ к вычислительным ресурсам только для авторизованных пользователей. Система идеально подходит для сценариев, требующих быстрой обработки сложных математических выражений для множества пользователей, таких как образовательные платформы, научные вычисления или облачные сервисы для расчетов.

Архитектура системы основана на модели клиент-сервер и включает два основных компонента: **Оркестратор**, который управляет взаимодействием с пользователями и координирует задачи, и **Агент**, выполняющий вычисления бинарных подвыражений. Для обеспечения низкой задержки используется **gRPC**, для хранения данных — **PostgreSQL**, а для безопасности — **аутентификация на основе JWT**. Вычисления распределяются между несколькими рабочими горутинами, что значительно повышает производительность при обработке больших или сложных выражений.

Этот документ предоставляет исчерпывающее руководство по проекту, включая описание архитектуры, инструкции по установке, подробное описание компонентов и примеры использования. Независимо от того, являетесь ли вы разработчиком, желающим внести вклад, исследователем, изучающим распределенные системы, или пользователем, интересующимся вычислительными сервисами, этот README поможет вам разобраться в системе и эффективно использовать её.

## Структура проекта
Проект организован в модульную структуру, обеспечивающую удобство сопровождения и совместной работы. Ниже приведено подробное описание структуры директорий и назначение каждого компонента:

```
api/
  ├── gen/                    # Сгенерированный код для gRPC-сервисов
  │   └── go/
  │       ├── calculation_grpc.pb.go  # Автоматически сгенерированные заглушки gRPC
  │       └── calculation.pb          # Скомпилированные определения протобуферов
  ├── proto/                  # Исходные файлы Protocol Buffers
  │   └── calculation.proto   # Определяет интерфейсы gRPC-сервисов и структуры сообщений
cmd/
  ├── agent/                  # Исполняемый файл агента
  │   ├── cmd.go             # Точка входа для запуска агента
  │   ├── Dockerfile         # Конфигурация Docker для сборки образа агента
  ├── orchestrator/           # Исполняемый файл оркестратора
  │   ├── cmd.go             # Точка входа для запуска оркестратора
  │   ├── Dockerfile         # Конфигурация Docker для сборки образа оркестратора
internal/
  ├── agent/                  # Основная логика агента
  │   ├── agent.go           # Управляет жизненным циклом агента и координирует рабочие процессы
  │   ├── grpc.stream_agent.go  # Реализует потоковую передачу gRPC для получения задач и отправки результатов
  │   ├── worker.go          # Определяет логику рабочих процессов для вычисления бинарных операций
  │   └── worker_test.go     # Модульные тесты для рабочих процессов
  ├── config/                 # Управление конфигурацией
  │   └── config.go          # Парсинг переменных окружения и установка значений по умолчанию
  ├── models/                 # Модели данных системы
  │   └── models.go          # Структуры для пользователей, выражений, задач и результатов
  ├── orchestrator/           # Основная логика оркестратора
  │   ├── calculator.go      # Обработка парсинга выражений и построение AST
  │   ├── calculator_test.go # Модульные тесты для модуля калькулятора
  │   ├── grpc.stream_orch.go  # Реализация потоковой передачи gRPC для распределения задач
  │   ├── grpc.stream_orch_test.go  # Тесты для потоковой передачи gRPC оркестратора
  │   ├── handlers.go        # Обработчики HTTP API для пользовательских запросов
  │   └── orchestrator.go    # Координация распределения задач и агрегации результатов
pkg/
  ├── ast/                    # Утилиты для работы с абстрактным синтаксическим деревом (AST)
  │   ├── ast.go             # Определяет структуры и операции узлов AST
  │   ├── ast_test.go        # Модульные тесты для функциональности AST
  │   ├── build.go           # Логика построения AST из выражений
  │   ├── errors.go          # Пользовательские типы ошибок для обработки AST
  │   ├── errors_test.go     # Тесты для обработки ошибок AST
  │   ├── rpn.go             # Преобразование выражений в обратную польскую нотацию (RPN)
  │   ├── rpn_test.go        # Тесты для преобразования в RPN
  │   ├── tokens.go          # Логика токенизации для парсинга выражений
  │   ├── tokens_test.go     # Тесты для токенизации
  │   └── vars.go            # Поддержка переменных в выражениях (для будущих расширений)
  ├── crypto/                 # Криптографические утилиты для обеспечения безопасности
  │   ├── password/          # Хеширование и проверка паролей
  │   │   ├── password.go   # Реализует безопасное хеширование паролей
  │   │   └── password_test.go  # Тесты для утилит паролей
  │   └── jwt/               # Аутентификация на основе JSON Web Token (JWT)
  │       ├── jwt.go        # Генерация и проверка JWT-токенов
  │       └── jwt_test.go   # Тесты для функциональности JWT
  ├── database/               # Слой взаимодействия с базой данных
  │   ├── sql.db.go         # Реализует SQL-операции для PostgreSQL
  │   └── sql.db_test.go    # Тесты для операций с базой данных
  ├── data/                   # Директория для статических данных или временного хранения
 
.gitignore                     # Указывает файлы и директории, игнорируемые Git
docker-compose.yml             # Конфигурация для развертывания нескольких контейнеров Docker
go.mod                         # Зависимости Go-модулей
go.sum                         # Контрольные суммы зависимостей Go
README.md                      # Полная документация проекта
```

## Особенности
Распределенный вычислитель арифметических выражений предлагает богатый набор функций, отвечающих различным сценариям использования:

- **Параллельная обработка**: Распределяет бинарные операции между несколькими рабочими процессами, используя модель конкурентности Go для оптимальной производительности.
- **Безопасная аутентификация**: Реализует аутентификацию на основе JWT и сессии на основе cookie, гарантируя доступ только для авторизованных пользователей.
- **Масштабируемая архитектура**: Поддерживает одновременную обработку выражений от нескольких пользователей с изолированными каналами для каждого выражения.
- **Интеграция gRPC**: Использует двунаправленную потоковую передачу gRPC для эффективной связи с низкой задержкой между оркестратором и агентами.
- **Обработка на основе AST**: Парсит выражения в абстрактные синтаксические деревья для надежных и гибких вычислений.
- **Хранение данных**: Сохраняет данные пользователей, выражения и результаты в базе данных PostgreSQL для надежности и аудита.
- **Настраиваемая производительность**: Позволяет настраивать время вычислений и количество рабочих процессов через переменные окружения.
- **Обработка ошибок**: Предоставляет подробные сообщения об ошибках для некорректных выражений, сбоев аутентификации или системных проблем.
- **Модульная архитектура**: Организована в переиспользуемые пакеты, упрощающие расширение или интеграцию с другими системами.

## Требования
Перед началом работы с проектом убедитесь, что установлены следующие зависимости:

### Вариант с Docker (рекомендуется)
- **Docker**: Версия 24.0 или выше
  - Скачать: [Docker Desktop](https://www.docker.com/get-started)
  - Инструкции по установке зависят от операционной системы (Windows, macOS, Linux).
- **Docker Compose**: Обычно включен в состав Docker
  - Проверить: `docker-compose --version`
  - Если отсутствует, установить отдельно: [Docker Compose](https://docs.docker.com/compose/install/)

### Вариант без Docker
- **Go**: Версия 1.20 или выше
  - Скачать: [Go](https://go.dev/dl/)
  - Проверить: `go version`
  - Убедитесь, что `$GOPATH` настроен и добавлен в PATH.
- **Компилятор Protocol Buffers (protoc)**:
  - Скачать: [Protocol Buffers](https://github.com/protocolbuffers/protobuf/releases)
  - Проверить: `protoc --version`
  - Установить плагин Go для protoc: `go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`

## Установка и настройка
### Установка
1. **Клонирование репозитория**:
   Клонируйте проект с GitHub и перейдите в директорию проекта:
   ```
   git clone https://github.com/Vlad-PyDev/AsyncCalculationWebService.git
   cd AsyncCalculationWebService
   ```
2. **Установка зависимостей**:
   Убедитесь, что все зависимости Go установлены:
   ```
   go mod tidy
   ```
   Эта команда загружает и разрешает зависимости, указанные в `go.mod`.

### Настройка
Система настраивается через файл `.env` в корневой директории. Создайте этот файл и добавьте следующие параметры:

```
TIME_ADDITION_MS=100          # Длительность (мс) для операций сложения
TIME_SUBTRACTION_MS=100       # Длительность (мс) для операций вычитания
TIME_MULTIPLICATIONS_MS=200   # Длительность (мс) для операций умножения
TIME_DIVISIONS_MS=200         # Длительность (мс) для операций деления
COMPUTING_POWER=4             # Количество рабочих горутин на агента
ORCHESTRATOR_ADDRESS=localhost:5000  # Адрес оркестратора (используйте "orchestrator:5000" с Docker)
DATABASE_URL=postgres://user:password@localhost:5432/calc_prl  # Строка подключения к PostgreSQL
JWT_SECRET=your-secret-key    # Секретный ключ для подписи JWT
```

**Примечания**:
- Если файл `.env` отсутствует или некоторые переменные не указаны, система использует значения по умолчанию (например, `localhost:5000` для адреса оркестратора в не-Docker окружении).
- Параметры `DATABASE_URL` и `JWT_SECRET` критически важны для продакшн-среды; убедитесь, что они защищены и не добавлены в систему контроля версий.
- Настройте `COMPUTING_POWER` в зависимости от возможностей вашего оборудования (например, установите значение, равное количеству ядер процессора, для оптимальной производительности).

### Запуск проекта
#### Использование Go
1. **Запуск PostgreSQL**:
   Убедитесь, что экземпляр PostgreSQL запущен и доступен. Для локального запуска используйте:
   ```
   docker run -d -p 5432:5432 -e POSTGRES_USER=user -e POSTGRES_PASSWORD=password -e POSTGRES_DB=calc_prl postgres
   ```
2. **Запуск оркестратора**:
   Оркестратор обрабатывает API-запросы и координирует задачи:
   ```
   go run ./cmd/orchestrator/cmd.go
   ```
3. **Запуск агента**:
   Агент выполняет вычисления:
   ```
   go run ./cmd/agent/cmd.go
   ```

#### Использование Docker
1. **Развертывание контейнеров**:
   Используйте Docker Compose для сборки и запуска оркестратора, агента и базы данных PostgreSQL:
   ```
   docker-compose up --build
   ```
   Эта команда:
   - Собирает образы Docker для оркестратора и агента.
   - Запускает контейнер PostgreSQL.
   - Соединяет все сервисы через сеть Docker.
2. **Остановка контейнеров**:
   После завершения работы остановите и удалите контейнеры:
   ```
   docker-compose down
   ```

**Совет**: Используйте `docker-compose logs` для просмотра логов контейнеров при отладке.

## Архитектура системы
### Обзор архитектуры
Система построена по распределенной, микросервисной архитектуре с двумя основными компонентами: **Оркестратор** и **Агент**. Компоненты взаимодействуют через потоки gRPC, обеспечивая эффективное распределение задач и агрегацию результатов. Оркестратор выступает в роли центрального узла, обрабатывая запросы пользователей, парсинг выражений и управление процессом вычислений. Агенты — это легковесные, масштабируемые рабочие процессы, выполняющие вычисления параллельно.

Система поддерживает одновременную работу с несколькими пользователями, причем выражения каждого пользователя обрабатываются независимо. Это достигается благодаря модели конкурентности на основе каналов, где каждое выражение имеет собственные каналы `tasks` и `results`. База данных PostgreSQL хранит учетные данные пользователей, выражения и результаты, обеспечивая сохранность данных и возможность аудита.

### Оркестратор
Оркестратор — это центральный компонент системы, отвечающий за:

- **Аутентификацию пользователей**:
  - Пользователи должны зарегистрироваться и войти в систему для получения доступа.
  - После успешного входа выдается JWT-токен, который включается в заголовок `Authorization` запросов.
  - Оркестратор устанавливает HTTP-cookie для упрощения управления сессиями в браузерах или API-клиентах.
  - Неавторизованные запросы отклоняются с кодом состояния `401`.
- **Парсинг выражений**:
  - Выражения парсятся в абстрактные синтаксические деревья (AST) с использованием модуля `pkg/ast`.
  - Некорректные выражения возвращают ошибку; корректным выражениям присваивается уникальный идентификатор.
- **Распределение задач**:
  - Создается хеш-таблица, отображающая идентификаторы узлов AST на указатели узлов для эффективного доступа.
  - Вычислимые узлы (бинарные операции) отправляются в канал `tasks` для обработки агентами.
- **Интеграция результатов**:
  - Результаты получаются через канал `results`.
  - Оркестратор обновляет AST, удаляет вычисленные ветви и продолжает обработку до полного вычисления выражения.
- **Управление конкурентностью**:
  - Каждое выражение — это объект с выделенными каналами `tasks` и `results`.
  - Менеджер каналов отображает каналы на идентификаторы выражений, обеспечивая точное соответствие результатов.

**Процесс вычислений**:
1. Парсинг выражения в AST и проверка его синтаксиса.
2. Сохранение выражения в базе данных со статусом "в процессе".
3. Построение хеш-таблицы из AST для эффективного доступа к узлам.
4. Обход AST, определение вычислимых узлов и отправка их в канал `tasks`.
5. Получение результатов от агентов через канал `results`, обновление AST и хеш-таблицы, удаление вычисленных ветвей.
6. Повторение процесса, пока в хеш-таблице не останется одно значение, сигнализирующее о завершении.
7. Сохранение конечного результата в базе данных и обновление статуса на "выполнено".

### Агент
Агент — это высокопроизводительный компонент, оптимизированный для вычислений. Основные обязанности включают:

- **Параллелизм на основе горутин**:
  - Запускает настраиваемое количество рабочих горутин (задается через `COMPUTING_POWER`).
  - Рабочие процессы выполняют задачи параллельно, максимально используя ресурсы процессора.
- **Потоковая передача gRPC**:
  - Подключается к оркестратору через двунаправленный поток gRPC.
  - Получает задачи и отправляет результаты в реальном времени.
- **Обработка задач**:
  - Рабочие процессы извлекают задачи из общего канала `tasks`.
  - Каждая задача представляет собой бинарную операцию (например, `2 + 3`).
  - Результаты (или ошибки) отправляются в канал `results` и пересылаются оркестратору.
- **Обработка ошибок**:
  - Обрабатывает краевые случаи, такие как деление на ноль или некорректные операнды.
  - Возвращает описательные сообщения об ошибках оркестратору.

**Рабочий процесс**:
1. Инициализация и подключение к оркестратору через gRPC.
2. Запуск рабочих горутин на основе `COMPUTING_POWER`.
3. Получение задач от оркестратора и их распределение по рабочим процессам через канал `tasks`.
4. Вычисление задач и отправка результатов (или ошибок) в канал `results`.
5. Пересылка результатов оркестратору через gRPC.

### База данных
Система использует PostgreSQL для постоянного хранения данных, управляемого модулем `pkg/database`. База данных хранит:

- **Пользователей**: Учетные данные (хешированные пароли) и метаданные.
- **Выражения**: Текст выражений, статус ("в процессе" или "выполнено") и результаты.
- **Задачи**: Промежуточные данные задач (опционально, для отладки или аудита).

База данных обеспечивает согласованность данных и поддерживает конкурентный доступ, что делает её подходящей для многопользовательских сред.

## Компоненты системы
### Оркестратор
Оркестратор предоставляет RESTful API для взаимодействия с пользователями и координирует работу с агентами для выполнения вычислений. Основные функции включают:

- **Управление пользователями**: Регистрация, вход и управление сессиями.
- **Обработка выражений**: Парсинг выражений, построение AST и управление рабочими процессами вычислений.
- **Координация задач**: Распределение задач агентам и агрегация результатов.
- **Взаимодействие с базой данных**: Сохранение и получение данных выражений.

#### API оркестратора
**Примечание**: Cookie, установленные при входе, могут использоваться вместо ручного включения JWT-токена в запросы.

1. **Регистрация**:
   ```
   curl --location 'localhost:8080/api/v1/register' \
   --header 'Content-Type: application/json' \
   --data '{
     "login": "<ваш_логин>",
     "password": "<ваш_пароль>"
   }'
   ```
   **Ответ**:
   - `200`: Пользователь успешно зарегистрирован
   - Ошибка:
     ```json
     {"error": "<сообщение_об_ошибке>"}
     ```

2. **Вход**:
   ```
   curl --location 'localhost:8080/api/v1/login' \
   --header 'Content-Type: application/json' \
   --data '{
     "login": "<ваш_логин>",
     "password": "<ваш_пароль>"
   }'
   ```
   **Ответ**:
   - Успех:
     ```json
     {"jwt": "<ваш_токен>"}
     ```
   - Ошибка:
     ```json
     {"error": "<сообщение_об_ошибке>"}
     ```

3. **Отправка выражения**:
   ```
   curl --location 'localhost:8080/api/v1/calculate' \
   --header 'Content-Type: application/json' \
   --header 'Authorization: Bearer <ваш_токен>' \
   --data '{
     "expression": "2+2*2"
   }'
   ```
   **Ответ**:
   - Успех:
     ```json
     {"id": "<идентификатор_выражения>"}
     ```
   - Ошибка:
     ```json
     {"error": "<сообщение_об_ошибке>"}
     ```

4. **Получение списка выражений**:
   ```
   curl --location 'localhost:8080/api/v1/expressions' \
   --header 'Authorization: Bearer <ваш_токен>'
   ```
   **Ответ**:
   - Успех:
     ```json
     {
       "expressions": [
         {
           "id": "<идентификатор_выражения>",
           "status": "<статус>",
           "result": "<результат>"
         }
       ]
     }
     ```
   - Ошибка:
     ```json
     {"error": "<сообщение_об_ошибке>"}
     ```

5. **Получение выражения по ID**:
   ```
   curl --location 'localhost:8080/api/v1/expressions/<id>' \
   --header 'Authorization: Bearer <ваш_токен>'
   ```
   **Ответ**:
   - Успех:
     ```json
     {
       "expression": {
         "id": "<идентификатор_выражения>",
         "status": "<статус>",
         "result": "<результат>"
       }
     }
     ```
   - Ошибка:
     ```json
     {"error": "<сообщение_об_ошибке>"}
     ```

### Агент
Агент отвечает за выполнение вычислительных задач, назначенных оркестратором. Он:

- Запускает несколько рабочих горутин для параллельной обработки.
- Взаимодействует с оркестратором через потоки gRPC.
- Грамотно обрабатывает ошибки, обеспечивая надежную работу.

## Примеры запросов и ответов
Ниже приведены подробные примеры взаимодействия с API, включая краевые случаи и сценарии ошибок для иллюстрации поведения системы.

1. **Регистрация**:
   - **Запрос** (Успешно):
     ```
     curl --location 'localhost:8080/api/v1/register' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "vedsatt",
       "password": "123"
     }'
     ```
     - **Ответ**: `200` (Пользователь успешно зарегистрирован)
   - **Запрос** (Пустой пароль):
     ```
     curl --location 'localhost:8080/api/v1/register' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "vedsatt",
       "password": ""
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "password cannot be empty"}
       ```
       - **Код**: `403`
   - **Запрос** (Пользователь уже существует):
     ```
     curl --location 'localhost:8080/api/v1/register' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "vedsatt",
       "password": "123"
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "user already exists"}
       ```
       - **Код**: `403`

2. **Вход**:
   - **Запрос** (Успешно):
     ```
     curl --location 'localhost:8080/api/v1/login' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "vedsatt",
       "password": "123"
     }'
     ```
     - **Ответ**:
       ```json
       {"jwt": "<very.secret.token>"}
       ```
       - **Код**: `200`
   - **Запрос** (Неправильный пароль):
     ```
     curl --location 'localhost:8080/api/v1/login' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "vedsatt",
       "password": ""
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "incorrect password"}
       ```
       - **Код**: `403`
   - **Запрос** (Пользователь не найден):
     ```
     curl --location 'localhost:8080/api/v1/login' \
     --header 'Content-Type: application/json' \
     --data '{
       "login": "devastated",
       "password": "123"
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "user not found"}
       ```
       - **Код**: `403`

3. **Отправка выражения**:
   - **Запрос** (Без токена):
     ```
     curl --location 'localhost:8080/api/v1/calculate' \
     --header 'Content-Type: application/json' \
     --data '{
       "expression": "2 + 2 * 2"
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "invalid token"}
       ```
       - **Код**: `401`
   - **Запрос** (С токеном):
     ```
     curl --location 'localhost:8080/api/v1/calculate' \
     --header 'Content-Type: application/json' \
     --header 'Authorization: Bearer <ваш_токен>' \
     --data '{
       "expression": "2 + 2 * 2"
     }'
     ```
     - **Ответ**:
       ```json
       {"id": 1}
       ```
       - **Код**: `201`
   - **Запрос** (Некорректный ввод):
     ```
     curl --location 'localhost:8080/api/v1/calculate' \
     --header 'Content-Type: application/json' \
     --header 'Authorization: Bearer <ваш_токен>' \
     --data '{
       "exp": ""
     }'
     ```
     - **Ответ**:
       ```json
       {"error": "internal server error"}
       ```
       - **Код**: `500`

4. **Получение списка выражений**:
   - **Запрос**:
     ```
     curl --location 'localhost:8080/api/v1/expressions' \
     --header 'Authorization: Bearer <ваш_токен>'
     ```
   - **Ответ** (Успех):
     ```json
     {
       "expressions": [
         {
           "id": 2,
           "status": "in process",
           "result": ""
         },
         {
           "id": 1,
           "status": "done",
           "result": 6.0000
         }
       ]
     }
     ```
     - **Код**: `200`
   - **Ответ** (Пустая база данных):
     ```json
     {"error": "you haven't calculated any expressions yet"}
     ```
     - **Код**: `500`

5. **Получение выражения по ID**:
   - **Запрос**:
     ```
     curl --location 'localhost:8080/api/v1/expressions/1' \
     --header 'Authorization: Bearer <ваш_токен>'
     ```
   - **Ответ** (Успех):
     ```json
     {
       "expression": {
         "id": 1,
         "status": "in process",
         "result": ""
       }
     }
     ```
     - **Код**: `200`
   - **Ответ** (Выражение не найдено):
     ```json
     {"error": "expression does not exist"}
     ```
     - **Код**: `404`

## Контакты
Для вопросов, сообщений об ошибках или предложений по новым функциям:

- Откройте задачу (issue) в [репозитории GitHub](https://github.com/Vlad-PyDev/AsyncCalculationWebService).
